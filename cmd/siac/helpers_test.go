package main

import (
	"bytes"
	"io"
	"os"
	"regexp"
	"testing"

	"github.com/spf13/cobra"
	"gitlab.com/NebulousLabs/Sia/node"
	"gitlab.com/NebulousLabs/Sia/node/api/client"
	"gitlab.com/NebulousLabs/Sia/persist"
	"gitlab.com/NebulousLabs/Sia/siatest"
	"gitlab.com/NebulousLabs/errors"
)

// subTest is a helper struct for running subtests when tests can use the same
// test http client
type subTest struct {
	name string
	test func(*testing.T, client.Client)
}

// runSubTests is a helper function to run the subtests when tests can use the
// same test http client
func runSubTests(t *testing.T, directory string, tests []subTest) error {
	// Create a test node/client for this test group
	n, err := newTestNode(directory)
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if err := n.Close(); err != nil {
			t.Fatal(err)
		}
	}()
	// Run subtests
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			test.test(t, n.Client)
		})
	}
	return nil
}

// newTestNode creates a new Sia node for a test
func newTestNode(dir string) (*siatest.TestNode, error) {
	n, err := siatest.NewNode(node.AllModules(dir))
	if err != nil {
		return nil, errors.AddContext(err, "Error creating a new test node")
	}
	return n, nil
}

// siacTestDir creates a temporary Sia testing directory for a cmd/siac test,
// removing any files or directories that previously existed at that location.
// This should only every be called once per test. Otherwise it will delete the
// directory again.
func siacTestDir(testName string) string {
	path := siatest.TestDir("cmd/siac", testName)
	if err := os.MkdirAll(path, persist.DefaultDiskPermissionsTest); err != nil {
		panic(err)
	}
	return path
}

// cobraCmdSubTest is a helper struct for running siac Cobra commands subtests
// when subtests need command to run and expected output
type cobraCmdSubTest struct {
	name               string
	test               func(*testing.T, []string, string)
	cmd                []string
	expectedOutPattern string
}

// runCobraCmdSubTests is a helper function to run siac Cobra command subtests
// when subtests need command to run and expected output
func runCobraCmdSubTests(t *testing.T, tests []cobraCmdSubTest) error {
	// init commands for testing
	initCobraCmdsForTests()

	// Run subtests
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			test.test(t, test.cmd, test.expectedOutPattern)
		})
	}
	return nil
}

// testGenericCobraCmd is a helper function to test siac cobra commands
// specified in cmds for expected output regex pattern
func testGenericCobraCmd(t *testing.T, cmds []string, expOutPattern string) {
	// catch stdout and stderr
	c, err := startCatchingStdoutStderr()
	if err != nil {
		t.Fatal("Error starting catching stdout/stderr", err)
	}

	// execute command
	cobraOutput, _ := executeCobraCommand(rootCmd, cmds...)

	// stop catching stdout/stderr, get catched outputs
	siaOutput, err := c.stopCatchingStout()
	if err != nil {
		t.Fatal("Error stopping catching stdout/stderr", err)
	}

	// check output
	// There are 2 types of output:
	// 1) Output generated by Cobra commands (e.g. when using -h) or Cobra
	//    errors (e.g. unknown cobra commands or flags).
	// 2) Output generated by siac to stdout and to stderr
	var output string

	if cobraOutput != "" {
		output = cobraOutput
	} else if siaOutput != "" {
		output = siaOutput
	} else {
		t.Fatal("There was no output")
	}

	validPattern := regexp.MustCompile(expOutPattern)
	if !validPattern.MatchString(output) {
		t.Log("----- Expected patern: -----")
		t.Log(expOutPattern)

		t.Log("----- Cobra output: -----")
		t.Log(cobraOutput)

		t.Log("----- Sia output: -----")
		t.Log(siaOutput)

		t.Fatal()
	}
}

// initCobraCmdsForTests initializes siac cobra commands for testing
func initCobraCmdsForTests() {
	if cmdTesting {
		return
	}
	initCmds()
	initClient()
	cmdTesting = true
}

// executeCobraCommand is a pass-through function to execute siac cobra command
func executeCobraCommand(root *cobra.Command, args ...string) (output string, err error) {
	_, output, err = executeCobraCommandC(root, args...)
	return output, err
}

// executeCobraCommandC executes cobra command
func executeCobraCommandC(root *cobra.Command, args ...string) (c *cobra.Command, output string, err error) {
	buf := new(bytes.Buffer)
	root.SetOut(buf)
	root.SetErr(buf)
	root.SetArgs(args)

	c, err = root.ExecuteC()

	return c, buf.String(), err
}

// outputCatcher is a helper struct enabling to catch stdout and stderr during
// tests
type outputCatcher struct {
	origStdout *os.File
	origStderr *os.File
	outW       *os.File
	outC       chan string
}

// startCatchingStdoutStderr starts catching stdout and stderr in tests
func startCatchingStdoutStderr() (outputCatcher, error) {
	// redirect stdout, stderr
	origStdout := os.Stdout
	origStderr := os.Stderr
	r, w, err := os.Pipe()
	if err != nil {
		return outputCatcher{}, errors.New("Error opening pipe")
	}
	os.Stdout = w
	os.Stderr = w

	// capture redirected output
	outC := make(chan string)
	go func() {
		var b bytes.Buffer
		io.Copy(&b, r)
		outC <- b.String()
	}()

	c := outputCatcher{
		origStdout: origStdout,
		origStderr: origStderr,
		outW:       w,
		outC:       outC,
	}

	return c, nil
}

// stopCatchingStout stops catching stdout and stderr, catched output is
// returned
func (c outputCatcher) stopCatchingStout() (string, error) {
	// stop Stdout
	err := c.outW.Close()
	if err != nil {
		return "", err
	}
	os.Stdout = c.origStdout
	os.Stderr = c.origStderr
	output := <-c.outC

	return output, nil
}
